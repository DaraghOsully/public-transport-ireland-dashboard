<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Irish Public Transport Dashboard</title>
    <!-- React and ReactDOM from CDN for a lightweight single page app -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- PapaParse for CSV parsing and Chart.js for charts -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
      /* Basic styles for layout */
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        background-color: #f3f4f6;
        margin: 0;
        padding: 1rem;
        color: #1f2937;
      }
      h1 {
        text-align: center;
        font-size: 1.5rem;
        margin-bottom: 1rem;
      }
      .card {
        background: #ffffff;
        border-radius: 0.5rem;
        padding: 1rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
        margin-bottom: 1rem;
      }
      .filters {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-bottom: 1rem;
      }
      .filter-group {
        display: flex;
        flex-direction: column;
      }
      .summary-container {
        display: grid;
        gap: 1rem;
      }
      @media (min-width: 600px) {
        .summary-container {
          grid-template-columns: repeat(2, 1fr);
        }
      }
      .summary-card {
        background: #ffffff;
        border-radius: 0.5rem;
        padding: 0.75rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
      }
      .summary-title {
        font-weight: 600;
        margin-bottom: 0.25rem;
      }
      .summary-value {
        font-size: 1.5rem;
        font-weight: 700;
      }
      .summary-diff {
        font-size: 0.875rem;
      }
      .chart-container {
        position: relative;
        height: 400px;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script type="text/javascript">
      (function () {
        const { useState, useEffect, useRef } = React;
        // Data endpoints from the CSO PxStat API
        const DATA_JSON_URL =
          'https://ws.cso.ie/public/api.restful/PxStat.Data.Cube_API.ReadDataset/THA25/JSON-stat/2.0/en';
        // Use a local CSV file stored alongside index.html. When served via
        // GitHub Pages the CSV is hosted under the same origin so we avoid
        // crossâ€‘origin issues. See THA25.csv in the repo for the dataset.
        const DATA_CSV_URL = 'THA25.csv';

        // Parse JSON-stat response into mode metadata and weekly series
        function parseJsonStat(json) {
          const dimTime = json.dimension['TLIST(W1)'].category.index;
          const modeIds = json.dimension['C03935V04687'].category.index;
          const modeLabels = json.dimension['C03935V04687'].category.label;
          const values = json.value;
          const series = {};
          let idx = 0;
          for (let t = 0; t < dimTime.length; t++) {
            const weekKey = dimTime[t];
            for (let m = 0; m < modeIds.length; m++) {
              const modeId = modeIds[m];
              const value = values[idx++];
              if (!series[modeId]) series[modeId] = [];
              series[modeId].push({ week: weekKey, value: value === null ? null : Number(value) });
            }
          }
          const modes = modeIds.map((id) => ({ id, name: modeLabels[id] }));
          return { modes, series };
        }

        // Parse CSV fallback into same structure as parseJsonStat
        function parseCsv(text) {
          const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
          const series = {};
          const modeSet = new Set();
          for (const row of parsed.data) {
            const mode = row['C03935V04687'] || row['MODE'] || row['C03935V04687 '] || row['C03935V04687'];
            const week = row['TLIST(W1)'] || row['WEEK'] || row['TLIST(W1) '];
            const valStr = row['value'] || row['VALUE'] || row['Observation'];
            const value = valStr === undefined || valStr === '' ? null : Number(valStr);
            if (!mode || !week) continue;
            modeSet.add(mode);
            if (!series[mode]) series[mode] = [];
            series[mode].push({ week, value: isNaN(value) ? null : value });
          }
          const modes = Array.from(modeSet).map((id) => ({ id, name: id }));
          return { modes, series };
        }

        // Parse a week identifier like 2019W01 into numeric year and week
        function parseWeek(weekId) {
          if (!weekId || typeof weekId !== 'string' || weekId.length < 6) {
            return { year: 0, week: 0 };
          }
          const yearPart = weekId.slice(0, 4);
          const weekPart = weekId.slice(5);
          const year = parseInt(yearPart, 10);
          const weekStr = weekPart.replace(/^0+/, '') || '0';
          const week = parseInt(weekStr, 10);
          if (isNaN(year) || isNaN(week)) return { year: 0, week: 0 };
          return { year, week };
        }

        // Compute maximum week observed for each year
        function computeMaxWeekByYear(series) {
          const maxWeeks = {};
          Object.keys(series).forEach((mode) => {
            series[mode].forEach(({ week }) => {
              const { year, week: wk } = parseWeek(week);
              if (!year || !wk) return;
              if (!maxWeeks[year] || wk > maxWeeks[year]) {
                maxWeeks[year] = wk;
              }
            });
          });
          return maxWeeks;
        }

        // Aggregate weekly series into annual totals for all weeks
        function aggregateByYear(series) {
          const agg = {};
          Object.keys(series).forEach((mode) => {
            series[mode].forEach(({ week, value }) => {
              if (value === null || isNaN(value)) return;
              const year = parseInt(week.slice(0, 4), 10);
              if (!agg[year]) agg[year] = {};
              if (!agg[year][mode]) agg[year][mode] = 0;
              agg[year][mode] += value;
            });
          });
          return agg;
        }

        // Aggregate weekly series within a given week range [startWeek, endWeek]
        function aggregateByYearWeekRange(series, startWeek, endWeek) {
          const agg = {};
          Object.keys(series).forEach((mode) => {
            series[mode].forEach(({ week, value }) => {
              if (value === null || isNaN(value)) return;
              const { year, week: wk } = parseWeek(week);
              if (!year || !wk) return;
              if (wk < startWeek || wk > endWeek) return;
              if (!agg[year]) agg[year] = {};
              if (!agg[year][mode]) agg[year][mode] = 0;
              agg[year][mode] += value;
            });
          });
          return agg;
        }

        // Compute CAGR-based projections with option to exclude the last year if partial
        function computeProjectionsAdjusted(agg, years, modes, horizon = 5, excludeLast) {
          const projections = {};
          if (!years || years.length === 0) return projections;
          const lastIndex = years.length - 1;
          const lastFullIndex = excludeLast && years.length > 1 ? years.length - 2 : lastIndex;
          const firstYear = years[0];
          const lastFullYear = years[lastFullIndex];
          const periods = lastFullYear - firstYear;
          modes.forEach((mode) => {
            const id = mode.id;
            const startVal = agg[firstYear]?.[id] ?? 0;
            const endVal = agg[lastFullYear]?.[id] ?? 0;
            let cagr = 0;
            if (startVal > 0 && periods > 0) {
              cagr = Math.pow(endVal / startVal, 1 / periods) - 1;
            }
            let base = agg[years[lastIndex]]?.[id] ?? 0;
            projections[id] = [];
            for (let i = 1; i <= horizon; i++) {
              base = base * (1 + cagr);
              projections[id].push({ year: years[lastIndex] + i, value: base });
            }
          });
          return projections;
        }

        function App() {
          const [loading, setLoading] = useState(true);
          const [error, setError] = useState(null);
          const [modes, setModes] = useState([]);
          const [series, setSeries] = useState({});
          const [selectedModes, setSelectedModes] = useState([]);
          const [yearRange, setYearRange] = useState([2019, 2025]);
          const [weekRange, setWeekRange] = useState([1, 52]);
          const [maxWeek, setMaxWeek] = useState(52);
          const [agg, setAgg] = useState({});
          const chartRef = useRef(null);
          const chartInstanceRef = useRef(null);

          // Load dataset on mount. We always fetch the CSV file from the same origin
          // (THA25.csv) which is stored in the repository alongside index.html.
          useEffect(() => {
            async function load() {
              try {
                const resp = await fetch(DATA_CSV_URL);
                if (!resp.ok) throw new Error('CSV fetch failed');
                const text = await resp.text();
                const { modes: mds, series: srs } = parseCsv(text);
                const aggregated = aggregateByYear(srs);
                const mwByYear = computeMaxWeekByYear(srs);
                const maxVal = Math.max(...Object.values(mwByYear));
                setModes(mds);
                setSeries(srs);
                setAgg(aggregated);
                setMaxWeek(maxVal);
                setWeekRange([1, maxVal]);
                setLoading(false);
                setSelectedModes(mds.map((m) => m.id));
              } catch (err) {
                setError(err.message);
                setLoading(false);
              }
            }
            load();
          }, []);

          // Draw or update chart when dependencies change
          useEffect(() => {
            if (loading || selectedModes.length === 0) return;
            drawChart();
          }, [loading, selectedModes, yearRange, weekRange, series]);

          function drawChart() {
            const ctx = chartRef.current.getContext('2d');
            // Destroy existing instance
            if (chartInstanceRef.current) {
              chartInstanceRef.current.destroy();
            }
            // Compute filtered aggregates within selected week range
            const filteredAgg = aggregateByYearWeekRange(series, weekRange[0], weekRange[1]);
            const allYears = Object.keys(filteredAgg)
              .map((y) => Number(y))
              .sort((a, b) => a - b);
            const [startYear, endYear] = yearRange;
            const visibleYears = allYears.filter((y) => y >= startYear && y <= endYear);
            // Determine if the last year is partial (selected week range ends before max week for that year)
            const maxWeekForEndYear = computeMaxWeekByYear(series)[endYear] || maxWeek;
            const isPartial = weekRange[1] < maxWeekForEndYear;
            // Compute projections
            const projections = computeProjectionsAdjusted(filteredAgg, allYears, modes, 5, isPartial);
            // Build labels combining history and projection years
            const histLabels = visibleYears.map((y) => String(y));
            const projYearSet = new Set();
            selectedModes.forEach((id) => {
              projections[id]?.forEach((p) => {
                projYearSet.add(String(p.year));
              });
            });
            const projLabels = Array.from(projYearSet).filter((y) => !histLabels.includes(y)).sort();
            const labels = histLabels.concat(projLabels);
            // Assign colours (cycle through a palette)
            const palette = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'];
            const datasets = [];
            selectedModes.forEach((id, idx) => {
              const colour = palette[idx % palette.length];
              // Historical data points (null for projection labels)
              const histData = labels.map((label) => {
                const y = parseInt(label, 10);
                return histLabels.includes(label) ? filteredAgg[y]?.[id] ?? null : null;
              });
              datasets.push({
                label: modes.find((m) => m.id === id)?.name || id,
                data: histData,
                borderColor: colour,
                backgroundColor: colour,
                tension: 0.2,
                spanGaps: true,
              });
              // Projection line (dashed)
              const projData = labels.map((label) => {
                const entry = projections[id]?.find((p) => String(p.year) === label);
                return entry ? entry.value : null;
              });
              datasets.push({
                label: (modes.find((m) => m.id === id)?.name || id) + ' (proj)',
                data: projData,
                borderColor: colour,
                backgroundColor: colour,
                borderDash: [5, 5],
                tension: 0.2,
                spanGaps: true,
              });
            });
            const chart = new Chart(ctx, {
              type: 'line',
              data: { labels, datasets },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'nearest', axis: 'x', intersect: false },
                plugins: { legend: { position: 'top' } },
                scales: {
                  y: {
                    ticks: { callback: (value) => value.toLocaleString('en-IE') },
                    title: { display: true, text: 'Journeys' },
                  },
                  x: {
                    title: { display: true, text: 'Year' },
                  },
                },
              },
            });
            chartInstanceRef.current = chart;
          }

          // Summary cards using filtered aggregate
          const filteredAgg = aggregateByYearWeekRange(series, weekRange[0], weekRange[1]);
          const [startYear, endYear] = yearRange;
          const summaryCards = selectedModes.map((id) => {
            const lastVal = filteredAgg[endYear]?.[id] ?? 0;
            const prevVal = filteredAgg[endYear - 1]?.[id] ?? 0;
            const diff = lastVal - prevVal;
            const diffPct = prevVal ? (diff / prevVal) * 100 : 0;
            return React.createElement(
              'div',
              { key: id, className: 'summary-card' },
              React.createElement('div', { className: 'summary-title' }, modes.find((m) => m.id === id)?.name || id),
              React.createElement('div', { className: 'summary-value' }, lastVal ? lastVal.toLocaleString('en-IE') : 'N/A'),
              React.createElement(
                'div',
                {
                  className: 'summary-diff',
                  style: { color: diff >= 0 ? '#059669' : '#b91c1c' },
                },
                (diff >= 0 ? '+' : '') + diff.toLocaleString('en-IE') + ' (' + diffPct.toFixed(1) + '%)',
              ),
              React.createElement('div', { style: { fontSize: '0.75rem', color: '#6b7280' } },
                endYear + ' vs ' + (endYear - 1) + ' (Weeks ' + weekRange[0] + '\u2013' + weekRange[1] + ')'),
            );
          });

          if (loading) {
            return React.createElement('div', { className: 'card' }, 'Loading dataâ€¦');
          }
          if (error) {
            return React.createElement('div', { className: 'card', style: { color: 'red' } }, 'Error: ' + error);
          }

          const yearsAvailable = Object.keys(agg)
            .map((y) => Number(y))
            .sort((a, b) => a - b);
          return React.createElement(
            'div',
            null,
            React.createElement('h1', null, 'Irish Public Transport Dashboard'),
            // Filters
            React.createElement(
              'div',
              { className: 'card filters' },
              // Start year
              React.createElement(
                'div',
                { className: 'filter-group' },
                React.createElement('label', { htmlFor: 'startYear' }, 'Start year'),
                React.createElement(
                  'select',
                  {
                    id: 'startYear',
                    value: yearRange[0],
                    onChange: (e) => {
                      const newStart = Number(e.target.value);
                      setYearRange([newStart, Math.max(newStart, yearRange[1])]);
                    },
                  },
                  yearsAvailable.map((y) =>
                    React.createElement(
                      'option',
                      { key: y, value: y, disabled: y > yearRange[1] },
                      y,
                    ),
                  ),
                ),
              ),
              // End year
              React.createElement(
                'div',
                { className: 'filter-group' },
                React.createElement('label', { htmlFor: 'endYear' }, 'End year'),
                React.createElement(
                  'select',
                  {
                    id: 'endYear',
                    value: yearRange[1],
                    onChange: (e) => {
                      const newEnd = Number(e.target.value);
                      setYearRange([Math.min(newEnd, yearRange[0]), newEnd]);
                    },
                  },
                  yearsAvailable.map((y) =>
                    React.createElement(
                      'option',
                      { key: y, value: y, disabled: y < yearRange[0] },
                      y,
                    ),
                  ),
                ),
              ),
              // Start week
              React.createElement(
                'div',
                { className: 'filter-group' },
                React.createElement('label', { htmlFor: 'startWeek' }, 'Start week'),
                React.createElement(
                  'select',
                  {
                    id: 'startWeek',
                    value: weekRange[0],
                    onChange: (e) => {
                      const val = Number(e.target.value);
                      setWeekRange([val, Math.max(val, weekRange[1])]);
                    },
                  },
                  Array.from({ length: maxWeek }, (_, i) => i + 1).map((w) =>
                    React.createElement(
                      'option',
                      { key: w, value: w, disabled: w > weekRange[1] },
                      w,
                    ),
                  ),
                ),
              ),
              // End week
              React.createElement(
                'div',
                { className: 'filter-group' },
                React.createElement('label', { htmlFor: 'endWeek' }, 'End week'),
                React.createElement(
                  'select',
                  {
                    id: 'endWeek',
                    value: weekRange[1],
                    onChange: (e) => {
                      const val = Number(e.target.value);
                      setWeekRange([Math.min(val, weekRange[0]), val]);
                    },
                  },
                  Array.from({ length: maxWeek }, (_, i) => i + 1).map((w) =>
                    React.createElement(
                      'option',
                      { key: w, value: w, disabled: w < weekRange[0] },
                      w,
                    ),
                  ),
                ),
              ),
              // Mode checkboxes
              React.createElement(
                'div',
                { className: 'filter-group', style: { flex: 1 } },
                React.createElement('span', null, 'Modes'),
                React.createElement(
                  'div',
                  { style: { display: 'flex', flexWrap: 'wrap', gap: '0.5rem' } },
                  modes.map((mode) =>
                    React.createElement(
                      'label',
                      { key: mode.id, style: { display: 'flex', alignItems: 'center' } },
                      React.createElement('input', {
                        type: 'checkbox',
                        checked: selectedModes.includes(mode.id),
                        onChange: () => {
                          setSelectedModes((prev) =>
                            prev.includes(mode.id)
                              ? prev.filter((m) => m !== mode.id)
                              : prev.concat(mode.id),
                          );
                        },
                      }),
                      React.createElement('span', { style: { marginLeft: '0.25rem' } }, mode.name),
                    ),
                  ),
                ),
              ),
            ),
            // Summary cards
            React.createElement('div', { className: 'summary-container' }, summaryCards),
            // Chart container
            React.createElement(
              'div',
              { className: 'card' },
              React.createElement('h2', { style: { marginBottom: '0.5rem' } }, 'Annual passenger journeys'),
              React.createElement('div', { className: 'chart-container' },
                React.createElement('canvas', { ref: chartRef }),
              ),
            ),
            // Note
            React.createElement(
              'p',
              { style: { fontSize: '0.75rem', color: '#6b7280', marginTop: '0.5rem' } },
              'Source: CSO THA25 dataset. Values reflect cumulative journeys within the selected week range. Projections use CAGR derived from complete years and start from the last observed value.',
            ),
          );
        }

        ReactDOM.createRoot(document.getElementById('app')).render(React.createElement(App));
      })();
    </script>
  </body>
</html>