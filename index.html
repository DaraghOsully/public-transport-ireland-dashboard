<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Irish Public Transport Dashboard</title>
    <!-- Pull in React and ReactDOM from a CDN.  These UMD builds are
         sufficient for a small single‑page app without a build step. -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- PapaParse for CSV parsing and Chart.js for visualisation -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
      /* Simple styles to make the dashboard readable.  You can tweak these
         values or replace them entirely with your own styles if desired. */
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
          Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        background-color: #f3f4f6;
        margin: 0;
        padding: 1rem;
        color: #1f2937;
      }
      h1 {
        text-align: center;
        font-size: 1.75rem;
        margin-bottom: 1rem;
      }
      .card {
        background: #ffffff;
        border-radius: 0.5rem;
        padding: 1rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
        margin-bottom: 1rem;
      }
      .filters {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-bottom: 1rem;
      }
      .filter-group {
        display: flex;
        flex-direction: column;
      }
      .summary-container {
        display: grid;
        gap: 1rem;
      }
      @media (min-width: 600px) {
        .summary-container {
          grid-template-columns: repeat(2, 1fr);
        }
      }
      .summary-card {
        background: #ffffff;
        border-radius: 0.5rem;
        padding: 0.75rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
      }
      .summary-title {
        font-weight: 600;
        margin-bottom: 0.25rem;
      }
      .summary-value {
        font-size: 1.5rem;
        font-weight: 700;
      }
      .summary-diff {
        font-size: 0.875rem;
      }
      .chart-container {
        position: relative;
        height: 400px;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script type="text/javascript">
      // Use React from the global scope.  These variables are provided by the
      // unpkg CDN scripts loaded above.
      const { useState, useEffect, useRef } = React;

      // Endpoints for the THA25 dataset.  We try JSON first because it
      // includes descriptive labels; if that fails we fall back to CSV.
      const DATA_JSON_URL =
        'https://ws.cso.ie/public/api.restful/PxStat.Data.Cube_API.ReadDataset/THA25/JSON-stat/2.0/en';
      const DATA_CSV_URL =
        'https://ws.cso.ie/public/api.restful/PxStat.Data.Cube_API.ReadDataset/THA25/CSV/1.0/en';

      /**
       * Parse the JSON‑stat representation into a structure of modes and
       * weekly series.  Returns an object with a `modes` array (id, name)
       * and a `series` map keyed by mode id to arrays of {week, value}.
       */
      function parseJsonStat(json) {
        const dimTime = json.dimension['TLIST(W1)'].category.index;
        const modeIds = json.dimension['C03935V04687'].category.index;
        const modeLabels = json.dimension['C03935V04687'].category.label;
        const values = json.value;
        const result = {};
        let idx = 0;
        for (let t = 0; t < dimTime.length; t++) {
          const weekKey = dimTime[t];
          for (let m = 0; m < modeIds.length; m++) {
            const modeId = modeIds[m];
            const value = values[idx++];
            if (!result[modeId]) result[modeId] = [];
            result[modeId].push({ week: weekKey, value: value === null ? null : Number(value) });
          }
        }
        const modes = modeIds.map((id) => ({ id, name: modeLabels[id] }));
        return { modes, series: result };
      }

      /**
       * Parse CSV fallback into the same structure as parseJsonStat.  Since
       * the CSV format may not include descriptive labels for modes, the
       * identifiers are used as names.
       */
      function parseCsv(text) {
        const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
        const series = {};
        const modeSet = new Set();
        for (const row of parsed.data) {
          const mode = row['C03935V04687'] || row['MODE'] || row['C03935V04687 '] || row['C03935V04687'];
          const week = row['TLIST(W1)'] || row['WEEK'] || row['TLIST(W1) '];
          const valStr = row['value'] || row['VALUE'] || row['Observation'];
          const value = valStr === undefined || valStr === '' ? null : Number(valStr);
          if (!mode || !week) continue;
          modeSet.add(mode);
          if (!series[mode]) series[mode] = [];
          series[mode].push({ week, value: isNaN(value) ? null : value });
        }
        const modes = Array.from(modeSet).map((id) => ({ id, name: id }));
        return { modes, series };
      }

      /**
       * Aggregate weekly series into annual totals per mode.  Missing values
       * are ignored when summing.
       */
      function aggregateByYear(series) {
        const agg = {};
        Object.keys(series).forEach((mode) => {
          series[mode].forEach(({ week, value }) => {
            if (value === null || isNaN(value)) return;
            const year = parseInt(week.slice(0, 4), 10);
            if (!agg[year]) agg[year] = {};
            if (!agg[year][mode]) agg[year][mode] = 0;
            agg[year][mode] += value;
          });
        });
        return agg;
      }

      /**
       * Compute year‑on‑year differences for each mode.
       */
      function computeYoY(agg, modes) {
        const years = Object.keys(agg)
          .map((y) => Number(y))
          .sort((a, b) => a - b);
        const diff = {};
        if (years.length < 2) return diff;
        const last = years[years.length - 1];
        const prev = years[years.length - 2];
        modes.forEach((mode) => {
          const id = mode.id;
          const current = agg[last]?.[id] ?? 0;
          const previous = agg[prev]?.[id] ?? 0;
          diff[id] = current - previous;
        });
        return diff;
      }

      /**
       * Compute CAGR projections for each mode for a fixed horizon of
       * years beyond the last available year.
       */
      function computeProjections(agg, years, modes, horizon = 5) {
        const proj = {};
        modes.forEach((mode) => {
          const id = mode.id;
          const values = years.map((y) => agg[y]?.[id] ?? 0);
          const startVal = values[0];
          const endVal = values[values.length - 1];
          let cagr = 0;
          if (startVal > 0 && values.length > 1) {
            cagr = Math.pow(endVal / startVal, 1 / (values.length - 1)) - 1;
          }
          proj[id] = [];
          let lastVal = endVal;
          const lastYear = years[years.length - 1];
          for (let i = 1; i <= horizon; i++) {
            lastVal = lastVal * (1 + cagr);
            proj[id].push({ year: lastYear + i, value: lastVal });
          }
        });
        return proj;
      }

      /**
       * Parse a week identifier such as "2019W01" into a numeric year and
       * week number.  Leading zeros on the week component are stripped.
       * Returns an object with `year` and `week` properties.  Invalid
       * inputs yield zeros.
       */
      function parseWeek(weekId) {
        if (!weekId || typeof weekId !== 'string' || weekId.length < 6) {
          return { year: 0, week: 0 };
        }
        const yearPart = weekId.slice(0, 4);
        const weekPart = weekId.slice(5); // skip 'W'
        const year = parseInt(yearPart, 10);
        const weekStr = weekPart.replace(/^0+/, '') || '0';
        const week = parseInt(weekStr, 10);
        if (isNaN(year) || isNaN(week)) return { year: 0, week: 0 };
        return { year, week };
      }

      /**
       * Determine the maximum observed week number for each year in the
       * dataset.  The series object maps mode IDs to arrays of weekly
       * observations.  Returns an object keyed by year with the highest
       * week number seen for that year.
       */
      function computeMaxWeekByYear(series) {
        const maxWeeks = {};
        Object.keys(series).forEach((mode) => {
          series[mode].forEach(({ week }) => {
            const { year, week: wk } = parseWeek(week);
            if (!year || !wk) return;
            if (!maxWeeks[year] || wk > maxWeeks[year]) {
              maxWeeks[year] = wk;
            }
          });
        });
        return maxWeeks;
      }

      /**
       * Aggregate weekly data into yearly totals for a given week range.
       * Only values whose week number lies within [startWeek, endWeek]
       * inclusive are accumulated.  Returns an object keyed by year
       * containing per-mode totals.
       */
      function aggregateByYearWeekRange(series, startWeek, endWeek) {
        const agg = {};
        Object.keys(series).forEach((mode) => {
          series[mode].forEach(({ week, value }) => {
            if (value === null || isNaN(value)) return;
            const { year, week: wk } = parseWeek(week);
            if (!year || !wk) return;
            if (wk < startWeek || wk > endWeek) return;
            if (!agg[year]) agg[year] = {};
            if (!agg[year][mode]) agg[year][mode] = 0;
            agg[year][mode] += value;
          });
        });
        return agg;
      }

      /**
       * Compute CAGR projections for each mode while optionally
       * excluding the final year from the CAGR calculation when it is
       * considered partial.  Growth rates are derived from the first
       * and last full years.  Projections always start from the last
       * available value (which may be partial) and extend a fixed
       * horizon into the future.
       */
      function computeProjectionsAdjusted(agg, years, modes, horizon = 5, excludeLastYear = false) {
        const proj = {};
        if (!years || years.length === 0) return proj;
        const lastIndex = years.length - 1;
        const lastFullIndex = excludeLastYear && years.length > 1 ? years.length - 2 : lastIndex;
        const firstYear = years[0];
        const lastFullYear = years[lastFullIndex];
        const periods = lastFullYear - firstYear;
        modes.forEach((mode) => {
          const id = mode.id;
          const startVal = agg[firstYear]?.[id] ?? 0;
          const endVal = agg[lastFullYear]?.[id] ?? 0;
          let cagr = 0;
          if (startVal > 0 && periods > 0) {
            cagr = Math.pow(endVal / startVal, 1 / periods) - 1;
          }
          let base = agg[years[lastIndex]]?.[id] ?? 0;
          proj[id] = [];
          for (let i = 1; i <= horizon; i++) {
            base = base * (1 + cagr);
            proj[id].push({ year: years[lastIndex] + i, value: base });
          }
        });
        return proj;
      }

      function App() {
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [modes, setModes] = useState([]);
        const [series, setSeries] = useState({});
        const [agg, setAgg] = useState({});
        const [selectedModes, setSelectedModes] = useState([]);
        const [yearRange, setYearRange] = useState([2018, 2024]);
        const [weekRange, setWeekRange] = useState([1, 52]);
        const [maxWeek, setMaxWeek] = useState(52);
        const [maxWeekByYear, setMaxWeekByYear] = useState({});
        const chartRef = useRef(null);
        const chartInstanceRef = useRef(null);

        // Load data on mount
        useEffect(() => {
          async function load() {
            try {
              // First attempt JSON
              const res = await fetch(DATA_JSON_URL);
              if (!res.ok) throw new Error('JSON fetch error');
              const data = await res.json();
              const parsed = parseJsonStat(data);
              setModes(parsed.modes);
              setSeries(parsed.series);
              const aggregated = aggregateByYear(parsed.series);
              setAgg(aggregated);
              // Preselect all modes by default
              setSelectedModes(parsed.modes.map((m) => m.id));
              // Compute week metadata
              const mwByYear = computeMaxWeekByYear(parsed.series);
              const weeks = Object.values(mwByYear);
              const overallMax = weeks.length ? Math.max(...weeks) : 52;
              setMaxWeekByYear(mwByYear);
              setMaxWeek(overallMax);
              setWeekRange([1, overallMax]);
            } catch (errJson) {
              console.error(errJson);
              try {
                const csvRes = await fetch(DATA_CSV_URL);
                if (!csvRes.ok) throw new Error('CSV fetch error');
                const csvText = await csvRes.text();
                const parsed = parseCsv(csvText);
                setModes(parsed.modes);
                setSeries(parsed.series);
                const aggregated = aggregateByYear(parsed.series);
                setAgg(aggregated);
                setSelectedModes(parsed.modes.map((m) => m.id));
                // Compute week metadata for CSV
                const mwByYear = computeMaxWeekByYear(parsed.series);
                const weeks = Object.values(mwByYear);
                const overallMax = weeks.length ? Math.max(...weeks) : 52;
                setMaxWeekByYear(mwByYear);
                setMaxWeek(overallMax);
                setWeekRange([1, overallMax]);
              } catch (errCsv) {
                console.error(errCsv);
                setError('Failed to load data');
              }
            } finally {
              setLoading(false);
            }
          }
          load();
        }, []);

        // Redraw chart when data or filters change
        useEffect(() => {
          if (loading) return;
          drawChart();
        }, [loading, selectedModes, yearRange, weekRange, series, maxWeekByYear]);

        function drawChart() {
          const ctx = chartRef.current.getContext('2d');
          if (chartInstanceRef.current) {
            chartInstanceRef.current.destroy();
          }
          // Filter series by selected modes
          const filteredSeries = {};
          selectedModes.forEach((id) => {
            filteredSeries[id] = series[id];
          });
          // Aggregate by year within week range
          const aggRange = aggregateByYearWeekRange(filteredSeries, weekRange[0], weekRange[1]);
          // Determine visible years
          const years = Object.keys(aggRange)
            .map((y) => Number(y))
            .sort((a, b) => a - b)
            .filter((y) => y >= yearRange[0] && y <= yearRange[1]);
          // Determine if last year is partial (weekRange[1] < maxWeekByYear[year])
          const lastYear = years[years.length - 1];
          const isPartial = weekRange[1] < (maxWeekByYear[lastYear] || weekRange[1]);
          // Compute projections using adjusted CAGR
          const projections = computeProjectionsAdjusted(aggRange, years, modes.filter((m) => selectedModes.includes(m.id)), 5, isPartial);
          // Prepare data
          const labels = years.concat(Array.from({ length: 5 }, (_, i) => lastYear + i + 1)).map(String);
          const datasets = [];
          // Generate colours for lines
          const colours = ['#ef4444', '#10b981', '#3b82f6', '#f59e0b', '#8b5cf6', '#e11d48'];
          let colourIndex = 0;
          // Actual data
          selectedModes.forEach((id) => {
            const colour = colours[colourIndex % colours.length];
            colourIndex++;
            const data = labels.map((label) => {
              const y = parseInt(label, 10);
              return aggRange[y]?.[id] ?? null;
            });
            datasets.push({
              label: modes.find((m) => m.id === id)?.name || id,
              data: data,
              borderColor: colour,
              backgroundColor: colour,
              tension: 0.2,
              spanGaps: true,
            });
          });
          // Projection data: dashed lines
          selectedModes.forEach((id) => {
            const colour = colours[colourIndex % colours.length];
            colourIndex++;
            // For each label, if there's a projection entry for that year, include its value; otherwise null
            const projData = labels.map((label) => {
              const entries = projections[id] || [];
              const match = entries.find((p) => String(p.year) === label);
              return match ? match.value : null;
            });
            datasets.push({
              label: (modes.find((m) => m.id === id)?.name || id) + ' (proj)',
              data: projData,
              borderColor: colour,
              backgroundColor: colour,
              borderDash: [5, 5],
              tension: 0.2,
              spanGaps: true,
            });
          });
          // Create the chart
          const chart = new Chart(ctx, {
            type: 'line',
            data: { labels, datasets },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: 'nearest', axis: 'x', intersect: false },
              plugins: {
                legend: { position: 'top' },
              },
              scales: {
                y: {
                  ticks: {
                    callback: (value) => value.toLocaleString('en-IE'),
                  },
                  title: {
                    display: true,
                    text: 'Journeys',
                  },
                },
                x: {
                  title: {
                    display: true,
                    text: 'Year',
                  },
                },
              },
            },
          });
          chartInstanceRef.current = chart;
        }

        if (loading) {
          return React.createElement('div', { className: 'card' }, 'Loading data…');
        }
        if (error) {
          return React.createElement(
            'div',
            { className: 'card', style: { color: 'red' } },
            'Error: ' + error,
          );
        }
        const allYears = Object.keys(agg)
          .map((y) => Number(y))
          .sort((a, b) => a - b);
        const [startYear, endYear] = yearRange;
        // Recompute aggregated totals within the selected week range for
        // summary cards.  This includes all years so that differences
        // can be computed relative to the previous year even if it is
        // outside the visible range.
        const aggFiltered = aggregateByYearWeekRange(series, weekRange[0], weekRange[1]);
        const summaryCards = selectedModes.map((id) => {
          const lastYr = endYear;
          const prevYr = endYear - 1;
          const lastVal = aggFiltered[lastYr]?.[id] ?? 0;
          const prevVal = aggFiltered[prevYr]?.[id] ?? 0;
          const diff = lastVal - prevVal;
          const diffPct = prevVal ? (diff / prevVal) * 100 : 0;
          return React.createElement(
            'div',
            { key: id, className: 'summary-card' },
            React.createElement('div', { className: 'summary-title' },
              modes.find((m) => m.id === id)?.name || id,
            ),
            React.createElement(
              'div',
              { className: 'summary-value' },
              lastVal ? lastVal.toLocaleString('en-IE') : 'N/A',
            ),
            React.createElement(
              'div',
              {
                className: 'summary-diff',
                style: { color: diff >= 0 ? '#059669' : '#b91c1c' },
              },
              (diff >= 0 ? '+' : '') + diff.toLocaleString('en-IE') +
                ' (' + diffPct.toFixed(1) + '%)',
            ),
            React.createElement('div', { style: { fontSize: '0.75rem', color: '#6b7280' } },
              lastYr + ' vs ' + prevYr + ' (Weeks ' + weekRange[0] + '\u2013' + weekRange[1] + ')',
            ),
          );
        });
        return React.createElement(
          'div',
          null,
          React.createElement('h1', null, 'Irish Public Transport Dashboard'),
          // Filters
          React.createElement(
            'div',
            { className: 'card filters' },
            // Start year selector
            React.createElement(
              'div',
              { className: 'filter-group' },
              React.createElement('label', { htmlFor: 'startYear' }, 'Start year'),
              React.createElement(
                'select',
                {
                  id: 'startYear',
                  value: startYear,
                  onChange: (e) => {
                    const newStart = Number(e.target.value);
                    setYearRange([newStart, Math.max(newStart, endYear)]);
                  },
                },
                allYears.map((y) =>
                  React.createElement(
                    'option',
                    { key: y, value: y, disabled: y > endYear },
                    y,
                  ),
                ),
              ),
            ),
            // End year selector
            React.createElement(
              'div',
              { className: 'filter-group' },
              React.createElement('label', { htmlFor: 'endYear' }, 'End year'),
              React.createElement(
                'select',
                {
                  id: 'endYear',
                  value: endYear,
                  onChange: (e) => {
                    const newEnd = Number(e.target.value);
                    setYearRange([Math.min(newEnd, startYear), newEnd]);
                  },
                },
                allYears.map((y) =>
                  React.createElement(
                    'option',
                    { key: y, value: y, disabled: y < startYear },
                    y,
                  ),
                ),
              ),
            ),

            // Start week selector
            React.createElement(
              'div',
              { className: 'filter-group' },
              React.createElement('label', { htmlFor: 'startWeek' }, 'Start week'),
              React.createElement(
                'select',
                {
                  id: 'startWeek',
                  value: weekRange[0],
                  onChange: (e) => {
                    const val = Number(e.target.value);
                    setWeekRange([val, Math.max(val, weekRange[1])]);
                  },
                },
                Array.from({ length: maxWeek }, (_, i) => i + 1).map((w) =>
                  React.createElement(
                    'option',
                    { key: w, value: w, disabled: w > weekRange[1] },
                    w,
                  ),
                ),
              ),
            ),
            // End week selector
            React.createElement(
              'div',
              { className: 'filter-group' },
              React.createElement('label', { htmlFor: 'endWeek' }, 'End week'),
              React.createElement(
                'select',
                {
                  id: 'endWeek',
                  value: weekRange[1],
                  onChange: (e) => {
                    const val = Number(e.target.value);
                    setWeekRange([Math.min(val, weekRange[0]), val]);
                  },
                },
                Array.from({ length: maxWeek }, (_, i) => i + 1).map((w) =>
                  React.createElement(
                    'option',
                    { key: w, value: w, disabled: w < weekRange[0] },
                    w,
                  ),
                ),
              ),
            ),
            // Mode checkboxes
            React.createElement(
              'div',
              { className: 'filter-group', style: { flex: 1 } },
              React.createElement('span', null, 'Modes'),
              React.createElement(
                'div',
                { style: { display: 'flex', flexWrap: 'wrap', gap: '0.5rem' } },
                modes.map((mode) =>
                  React.createElement(
                    'label',
                    { key: mode.id, style: { display: 'flex', alignItems: 'center' } },
                    React.createElement('input', {
                      type: 'checkbox',
                      checked: selectedModes.includes(mode.id),
                      onChange: () => {
                        setSelectedModes((prev) =>
                          prev.includes(mode.id)
                            ? prev.filter((m) => m !== mode.id)
                            : prev.concat(mode.id),
                        );
                      },
                    }),
                    React.createElement('span', { style: { marginLeft: '0.25rem' } }, mode.name),
                  ),
                ),
              ),
            ),
          ),
          // Summary cards
          React.createElement(
            'div',
            { className: 'summary-container' },
            summaryCards,
          ),
          // Chart container
          React.createElement(
            'div',
            { className: 'card' },
            React.createElement('h2', { style: { marginBottom: '0.5rem' } }, 'Annual passenger journeys'),
            React.createElement('div', { className: 'chart-container' },
              React.createElement('canvas', { ref: chartRef }),
            ),
          ),
          // Source note
          React.createElement(
            'p',
            { style: { fontSize: '0.75rem', color: '#6b7280', marginTop: '0.5rem' } },
            'Source: Central Statistics Office (CSO) – THA25 dataset. Values represent the cumulative total of passenger journeys within the selected week range for each year. Projections are illustrative and use compound annual growth rates based on complete years; when the last year is incomplete the CAGR is derived from the previous full year and projections start from the partial value.',
          ),
        );
      }

      ReactDOM.createRoot(document.getElementById('app')).render(React.createElement(App));
    </script>
  </body>
</html>
